<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>VR Box Shooter</title>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            background: #000;
        }
        #canvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-family: Arial;
            z-index: 100;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babylonjs/6.0.0/babylon.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babylonjs/6.0.0/babylonjs.loaders.min.js"></script>
</head>
<body>
    <div id="ui">
        <div>Score: <span id="score">0</span></div>
        <div>Space Combat - Press trigger to shoot</div>
        <button id="enterVR" style="padding: 10px; font-size: 16px;">Enter VR</button>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        class VRShootingGame {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.score = 0;
                this.boxes = [];
                this.bullets = [];
                this.init();
            }

            async init() {
                // Create engine and scene
                this.engine = new BABYLON.Engine(this.canvas, true);
                this.scene = new BABYLON.Scene(this.engine);
                
                // Create camera
                this.camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(0, 1.6, 0), this.scene);
                
                // Create space lighting
                const ambientLight = new BABYLON.HemisphericLight("ambient", new BABYLON.Vector3(0, 1, 0), this.scene);
                ambientLight.intensity = 0.3;
                ambientLight.diffuse = new BABYLON.Color3(0.8, 0.8, 1);
                
                // Add a directional light (like distant sun)
                const sunLight = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-1, -0.5, -1), this.scene);
                sunLight.intensity = 0.5;
                sunLight.diffuse = new BABYLON.Color3(1, 0.9, 0.7);
                
                // Create environment
                this.createEnvironment();
                
                // Setup WebXR
                await this.setupWebXR();
                
                // Create initial boxes
                this.createBoxes(10);
                
                // Start render loop
                this.engine.runRenderLoop(() => {
                    this.update();
                    this.scene.render();
                });
                
                // Handle resize
                window.addEventListener('resize', () => {
                    this.engine.resize();
                });
            }

            createEnvironment() {
                // Create space skybox with stars
                const skybox = BABYLON.MeshBuilder.CreateSphere("skyBox", {diameter: 200}, this.scene);
                const skyboxMaterial = new BABYLON.StandardMaterial("skyBox", this.scene);
                skyboxMaterial.backFaceCulling = false;
                skyboxMaterial.diffuseColor = new BABYLON.Color3(0.02, 0.02, 0.05);
                skyboxMaterial.emissiveColor = new BABYLON.Color3(0.02, 0.02, 0.05);
                skybox.material = skyboxMaterial;
                
                // Create star field
                this.createStarField();
                
                // Add some distant planets/nebulae
                this.createSpaceObjects();
            }
            
            createStarField() {
                const starCount = 2000;
                const positions = [];
                const colors = [];
                
                for (let i = 0; i < starCount; i++) {
                    // Random position on sphere
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const radius = 90 + Math.random() * 10;
                    
                    const x = radius * Math.sin(phi) * Math.cos(theta);
                    const y = radius * Math.cos(phi);
                    const z = radius * Math.sin(phi) * Math.sin(theta);
                    
                    positions.push(x, y, z);
                    
                    // Random star colors (white, blue, yellow, red)
                    const starType = Math.random();
                    if (starType < 0.7) {
                        colors.push(1, 1, 1, 1); // White
                    } else if (starType < 0.85) {
                        colors.push(0.8, 0.8, 1, 1); // Blue
                    } else if (starType < 0.95) {
                        colors.push(1, 1, 0.6, 1); // Yellow
                    } else {
                        colors.push(1, 0.6, 0.4, 1); // Red
                    }
                }
                
                // Create point cloud for stars
                const stars = new BABYLON.PointsCloudSystem("stars", 5, this.scene);
                stars.addPoints(starCount);
                
                const starMaterial = new BABYLON.StandardMaterial("starMaterial", this.scene);
                starMaterial.emissiveColor = new BABYLON.Color3(1, 1, 1);
                starMaterial.pointSize = 3;
                
                stars.mesh.material = starMaterial;
                
                // Set positions
                stars.initParticles = function() {
                    for (let p = 0; p < this.nbParticles; p++) {
                        const particle = this.particles[p];
                        const i = p * 3;
                        particle.position.x = positions[i];
                        particle.position.y = positions[i + 1];
                        particle.position.z = positions[i + 2];
                    }
                };
                
                stars.initParticles();
                stars.setParticles();
            }
            
            createSpaceObjects() {
                // Create distant planets
                for (let i = 0; i < 3; i++) {
                    const planet = BABYLON.MeshBuilder.CreateSphere("planet" + i, {diameter: 8 + Math.random() * 5}, this.scene);
                    
                    // Position far away
                    const angle = (i / 3) * Math.PI * 2;
                    planet.position = new BABYLON.Vector3(
                        Math.cos(angle) * 60,
                        Math.random() * 20 - 10,
                        Math.sin(angle) * 60
                    );
                    
                    const planetMaterial = new BABYLON.StandardMaterial("planetMat" + i, this.scene);
                    const colors = [
                        new BABYLON.Color3(0.8, 0.4, 0.2), // Mars-like
                        new BABYLON.Color3(0.3, 0.3, 0.8), // Neptune-like
                        new BABYLON.Color3(0.6, 0.6, 0.4)  // Desert planet
                    ];
                    planetMaterial.diffuseColor = colors[i];
                    planetMaterial.emissiveColor = colors[i].scale(0.1);
                    planet.material = planetMaterial;
                }
                
                // Create nebula-like clouds
                for (let i = 0; i < 5; i++) {
                    const cloud = BABYLON.MeshBuilder.CreateSphere("cloud" + i, {diameter: 15 + Math.random() * 10}, this.scene);
                    cloud.position = new BABYLON.Vector3(
                        (Math.random() - 0.5) * 150,
                        (Math.random() - 0.5) * 80,
                        (Math.random() - 0.5) * 150
                    );
                    
                    const cloudMaterial = new BABYLON.StandardMaterial("cloudMat" + i, this.scene);
                    cloudMaterial.alpha = 0.1;
                    cloudMaterial.emissiveColor = new BABYLON.Color3(
                        Math.random() * 0.5 + 0.2,
                        Math.random() * 0.3 + 0.1,
                        Math.random() * 0.8 + 0.2
                    );
                    cloud.material = cloudMaterial;
                }
            }

            async setupWebXR() {
                try {
                    // Create WebXR experience helper
                    this.xrHelper = await this.scene.createDefaultXRExperienceAsync({
                        floorMeshes: []
                    });
                    
                    // Setup controller input
                    this.xrHelper.input.onControllerAddedObservable.add((controller) => {
                        controller.onMotionControllerInitObservable.add((motionController) => {
                            // Get trigger component
                            const trigger = motionController.getComponent("xr-standard-trigger");
                            if (trigger) {
                                trigger.onButtonStateChangedObservable.add(() => {
                                    if (trigger.pressed) {
                                        this.shoot(controller);
                                    }
                                });
                            }
                        });
                    });
                    
                    // VR button
                    document.getElementById('enterVR').onclick = () => {
                        this.xrHelper.baseExperience.enterXRAsync("immersive-vr", "local-floor");
                    };
                    
                } catch (e) {
                    console.log("WebXR not supported:", e);
                    // Fallback for non-VR devices
                    this.canvas.addEventListener('click', () => {
                        this.shoot(null);
                    });
                }
            }

            createBoxes(count) {
                for (let i = 0; i < count; i++) {
                    this.createBox();
                }
            }

            createBox() {
                const box = BABYLON.MeshBuilder.CreateBox("box", {size: 0.5}, this.scene);
                
                // Random position in 3D space
                box.position = new BABYLON.Vector3(
                    Math.random() * 40 - 20,
                    Math.random() * 20 - 10,
                    Math.random() * 40 - 20
                );
                
                // Random velocity in all directions
                box.velocity = new BABYLON.Vector3(
                    (Math.random() - 0.5) * 0.15,
                    (Math.random() - 0.5) * 0.15,
                    (Math.random() - 0.5) * 0.15
                );
                
                // Material with emissive glow for space
                const material = new BABYLON.StandardMaterial("boxMat", this.scene);
                const baseColor = new BABYLON.Color3(
                    Math.random(),
                    Math.random(),
                    Math.random()
                );
                material.diffuseColor = baseColor;
                material.emissiveColor = baseColor.scale(0.2); // Slight glow
                box.material = material;
                
                // Store creation time for despawning
                box.createdTime = Date.now();
                
                this.boxes.push(box);
            }

            shoot(controller) {
                let origin, direction;
                
                if (controller && controller.pointer) {
                    // VR controller shooting
                    origin = controller.pointer.absolutePosition.clone();
                    direction = controller.pointer.forward.clone();
                } else {
                    // Desktop fallback - shoot from camera
                    origin = this.camera.position.clone();
                    direction = this.camera.getDirection(BABYLON.Vector3.Forward());
                }
                
                // Create bullet
                const bullet = BABYLON.MeshBuilder.CreateSphere("bullet", {diameter: 0.1}, this.scene);
                bullet.position = origin.clone();
                bullet.velocity = direction.scale(0.5);
                
                const bulletMaterial = new BABYLON.StandardMaterial("bulletMat", this.scene);
                bulletMaterial.emissiveColor = new BABYLON.Color3(0, 1, 1); // Cyan glow
                bulletMaterial.diffuseColor = new BABYLON.Color3(0, 1, 1);
                bullet.material = bulletMaterial;
                
                bullet.createdTime = Date.now();
                this.bullets.push(bullet);
                
                // Check for hits
                this.checkCollisions(origin, direction);
            }

            checkCollisions(origin, direction) {
                const ray = new BABYLON.Ray(origin, direction);
                const hit = this.scene.pickWithRay(ray, (mesh) => {
                    return this.boxes.includes(mesh);
                });
                
                if (hit && hit.pickedMesh) {
                    this.destroyBox(hit.pickedMesh);
                    this.updateScore(10);
                }
            }

            destroyBox(box) {
                // Remove from scene and array
                box.dispose();
                const index = this.boxes.indexOf(box);
                if (index > -1) {
                    this.boxes.splice(index, 1);
                }
                
                // Create new box to maintain count
                this.createBox();
            }

            updateScore(points) {
                this.score += points;
                document.getElementById('score').textContent = this.score;
            }

            update() {
                const deltaTime = this.engine.getDeltaTime() / 1000;
                const currentTime = Date.now();
                
                // Update boxes
                for (let i = this.boxes.length - 1; i >= 0; i--) {
                    const box = this.boxes[i];
                    
                    // Move box
                    box.position.addInPlace(box.velocity);
                    
                    // Rotate box
                    box.rotation.x += deltaTime;
                    box.rotation.y += deltaTime * 0.7;
                    
                    // Boundary check and bounce (larger space boundaries)
                    if (Math.abs(box.position.x) > 25) {
                        box.velocity.x *= -1;
                    }
                    if (Math.abs(box.position.y) > 20) {
                        box.velocity.y *= -1;
                    }
                    if (Math.abs(box.position.z) > 25) {
                        box.velocity.z *= -1;
                    }
                    
                    // Respawn old boxes
                    if (currentTime - box.createdTime > 30000) {
                        this.destroyBox(box);
                    }
                }
                
                // Update bullets
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    
                    bullet.position.addInPlace(bullet.velocity);
                    
                    // Remove old bullets
                    if (currentTime - bullet.createdTime > 3000) {
                        bullet.dispose();
                        this.bullets.splice(i, 1);
                    }
                }
            }
        }

        // Start the game
        new VRShootingGame();
    </script>
</body>
</html>
